### YamlMime:PythonClass
uid: azure.servicebus.ServiceBusReceiver
name: ServiceBusReceiver
fullName: azure.servicebus.ServiceBusReceiver
module: azure.servicebus
inheritances:
- azure.servicebus._base_handler.BaseHandler
- azure.servicebus._common.receiver_mixins.ReceiverMixin
summary: 'The ServiceBusReceiver class defines a high level interface for

  receiving messages from the Azure Service Bus Queue or Topic Subscription.


  The two primary channels for message receipt are *receive()* to make a single request
  for messages,

  and *for message in receiver:* to continuously receive incoming messages in an ongoing
  fashion.


  **Please use the `get_<queue/subscription>_receiver` method of ~azure.servicebus.ServiceBusClient
  to create a

  ServiceBusReceiver instance.**'
constructor:
  syntax: ServiceBusReceiver(fully_qualified_namespace, credential, **kwargs)
  parameters:
  - name: fully_qualified_namespace
    description: 'The fully qualified host name for the Service Bus namespace.

      The namespace format is: *<yournamespace>.servicebus.windows.net*.'
    isRequired: true
    types:
    - <xref:str>
  - name: credential
    description: 'The credential object used for authentication which

      implements a particular interface for getting tokens. It accepts

      credential objects generated by the azure-identity library and objects that
      implement the

      *get_token(self, *scopes)* method, or alternatively, an AzureSasCredential can
      be provided too.'
    isRequired: true
variables:
- description: 'The fully qualified host name for the Service Bus namespace.

    The namespace format is: *<yournamespace>.servicebus.windows.net*.'
  name: fully_qualified_namespace
  types:
  - <xref:str>
- description: The path of the entity that the client connects to.
  name: entity_path
  types:
  - <xref:str>
methods:
- uid: azure.servicebus.ServiceBusReceiver.abandon_message
  name: abandon_message
  summary: 'Abandon the message.


    This message will be returned to the queue and made available to be received again.'
  signature: abandon_message(message)
  parameters:
  - name: message
    description: The received message to be abandoned.
    isRequired: true
    types:
    - <xref:azure.servicebus.ServiceBusReceivedMessage>
  return:
    types:
    - <xref:None>
  examples:
  - "Abandon a received message.<!--[!code-python[Main](les\\sync_samples\\sample_code_servicebus.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\
    \\4\\\\azure-servicebus-7.2.0\\\\samples\\\\sync_samples\\\\sample_code_servicebus.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n       messages = servicebus_receiver.receive_messages(max_wait_time=5)\n  \
    \     for message in messages:\n           servicebus_receiver.abandon_message(message)\n\
    \n   ````\n"
- uid: azure.servicebus.ServiceBusReceiver.close
  name: close
  summary: 'Close down the handler links (and connection if the handler uses a separate
    connection).


    If the handler has already closed, this operation will do nothing.'
  signature: close()
  return:
    types:
    - <xref:None>
- uid: azure.servicebus.ServiceBusReceiver.complete_message
  name: complete_message
  summary: 'Complete the message.


    This removes the message from the queue.'
  signature: complete_message(message)
  parameters:
  - name: message
    description: The received message to be completed.
    isRequired: true
    types:
    - <xref:azure.servicebus.ServiceBusReceivedMessage>
  return:
    types:
    - <xref:None>
  examples:
  - "Complete a received message.<!--[!code-python[Main](les\\sync_samples\\sample_code_servicebus.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\
    \\4\\\\azure-servicebus-7.2.0\\\\samples\\\\sync_samples\\\\sample_code_servicebus.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n       messages = servicebus_receiver.receive_messages(max_wait_time=5)\n  \
    \     for message in messages:\n           servicebus_receiver.complete_message(message)\n\
    \n   ````\n"
- uid: azure.servicebus.ServiceBusReceiver.dead_letter_message
  name: dead_letter_message
  summary: 'Move the message to the Dead Letter queue.


    The Dead Letter queue is a sub-queue that can be

    used to store messages that failed to process correctly, or otherwise require
    further inspection

    or processing. The queue can also be configured to send expired messages to the
    Dead Letter queue.'
  signature: dead_letter_message(message, reason=None, error_description=None)
  parameters:
  - name: message
    description: The received message to be dead-lettered.
    isRequired: true
    types:
    - <xref:azure.servicebus.ServiceBusReceivedMessage>
  - name: reason
    description: The reason for dead-lettering the message.
    defaultValue: None
    types:
    - <xref:azure.servicebus.Optional>[<xref:str>]
  - name: error_description
    description: The detailed error description for dead-lettering the message.
    defaultValue: None
    types:
    - <xref:azure.servicebus.Optional>[<xref:str>]
  return:
    types:
    - <xref:None>
  examples:
  - "Dead letter a received message.<!--[!code-python[Main](les\\sync_samples\\sample_code_servicebus.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\
    \\4\\\\azure-servicebus-7.2.0\\\\samples\\\\sync_samples\\\\sample_code_servicebus.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n       messages = servicebus_receiver.receive_messages(max_wait_time=5)\n  \
    \     for message in messages:\n           servicebus_receiver.dead_letter_message(message)\n\
    \n   ````\n"
- uid: azure.servicebus.ServiceBusReceiver.defer_message
  name: defer_message
  summary: 'Defers the message.


    This message will remain in the queue but must be requested

    specifically by its sequence number in order to be received.'
  signature: defer_message(message)
  parameters:
  - name: message
    description: The received message to be deferred.
    isRequired: true
    types:
    - <xref:azure.servicebus.ServiceBusReceivedMessage>
  return:
    types:
    - <xref:None>
  examples:
  - "Defer a received message.<!--[!code-python[Main](les\\sync_samples\\sample_code_servicebus.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\
    \\4\\\\azure-servicebus-7.2.0\\\\samples\\\\sync_samples\\\\sample_code_servicebus.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n       messages = servicebus_receiver.receive_messages(max_wait_time=5)\n  \
    \     for message in messages:\n           servicebus_receiver.defer_message(message)\n\
    \n   ````\n"
- uid: azure.servicebus.ServiceBusReceiver.next
  name: next
  signature: next()
- uid: azure.servicebus.ServiceBusReceiver.peek_messages
  name: peek_messages
  summary: 'Browse messages currently pending in the queue.


    Peeked messages are not removed from queue, nor are they locked. They cannot be
    completed,

    deferred or dead-lettered.'
  signature: peek_messages(max_message_count=1, **kwargs)
  parameters:
  - name: max_message_count
    description: 'The maximum number of messages to try and peek. The default

      value is 1.'
    defaultValue: '1'
    types:
    - <xref:int>
  return:
    types:
    - <xref:azure.servicebus.List>[<xref:azure.servicebus.ServiceBusReceivedMessage>]
  examples:
  - "Look at pending messages in the queue.<!--[!code-python[Main](les\\sync_samples\\\
    sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\\
    a\\\\1\\\\s\\\\dist_temp\\\\4\\\\azure-servicebus-7.2.0\\\\samples\\\\sync_samples\\\
    \\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n   with servicebus_receiver:\n       messages =\
    \ servicebus_receiver.peek_messages()\n       for message in messages:\n     \
    \      print(str(message))\n\n   ````\n"
- uid: azure.servicebus.ServiceBusReceiver.receive_deferred_messages
  name: receive_deferred_messages
  summary: 'Receive messages that have previously been deferred.


    When receiving deferred messages from a partitioned entity, all of the supplied

    sequence numbers must be messages from the same partition.'
  signature: receive_deferred_messages(sequence_numbers, **kwargs)
  parameters:
  - name: sequence_numbers
    description: 'A list of the sequence numbers of messages that have been

      deferred.'
    isRequired: true
    types:
    - <xref:azure.servicebus.Union>[<xref:int>,<xref:azure.servicebus.List>[<xref:int>]]
  return:
    types:
    - <xref:azure.servicebus.List>[<xref:azure.servicebus.ServiceBusReceivedMessage>]
  examples:
  - "Receive deferred messages from ServiceBus.<!--[!code-python[Main](les\\sync_samples\\\
    sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\\
    a\\\\1\\\\s\\\\dist_temp\\\\4\\\\azure-servicebus-7.2.0\\\\samples\\\\sync_samples\\\
    \\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n   with servicebus_receiver:\n       deferred_sequenced_numbers\
    \ = []\n       messages = servicebus_receiver.receive_messages(max_wait_time=5)\n\
    \       for message in messages:\n           deferred_sequenced_numbers.append(message.sequence_number)\n\
    \           print(str(message))\n           servicebus_receiver.defer_message(message)\n\
    \n       received_deferred_msg = servicebus_receiver.receive_deferred_messages(\n\
    \           sequence_numbers=deferred_sequenced_numbers\n       )\n\n       for\
    \ msg in received_deferred_msg:\n           servicebus_receiver.complete_message(msg)\n\
    \n   ````\n"
- uid: azure.servicebus.ServiceBusReceiver.receive_messages
  name: receive_messages
  summary: 'Receive a batch of messages at once.


    This approach is optimal if you wish to process multiple messages simultaneously,
    or

    perform an ad-hoc receive as a single call.


    Note that the number of messages retrieved in a single batch will be dependent
    on

    whether *prefetch_count* was set for the receiver. If *prefetch_count* is not
    set for the receiver,

    the receiver would try to cache max_message_count (if provided) messages within
    the request to the service.


    This call will prioritize returning quickly over meeting a specified batch size,
    and so will

    return as soon as at least one message is received and there is a gap in incoming
    messages regardless

    of the specified batch size.'
  signature: receive_messages(max_message_count=1, max_wait_time=None)
  parameters:
  - name: max_message_count
    description: 'Maximum number of messages in the batch. Actual number

      returned will depend on prefetch_count and incoming stream rate.

      Setting to None will fully depend on the prefetch config. The default value
      is 1.'
    defaultValue: '1'
    types:
    - <xref:azure.servicebus.Optional>[<xref:int>]
  - name: max_wait_time
    description: 'Maximum time to wait in seconds for the first message to arrive.

      If no messages arrive, and no timeout is specified, this call will not return

      until the connection is closed. If specified, an no messages arrive within the

      timeout period, an empty list will be returned.'
    defaultValue: None
    types:
    - <xref:azure.servicebus.Optional>[<xref:float>]
  return:
    types:
    - <xref:azure.servicebus.List>[<xref:azure.servicebus.ServiceBusReceivedMessage>]
  examples:
  - "Receive messages from ServiceBus.<!--[!code-python[Main](les\\sync_samples\\\
    sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\\
    a\\\\1\\\\s\\\\dist_temp\\\\4\\\\azure-servicebus-7.2.0\\\\samples\\\\sync_samples\\\
    \\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n   with servicebus_receiver:\n       messages =\
    \ servicebus_receiver.receive_messages(max_wait_time=5)\n       for message in\
    \ messages:\n           print(str(message))\n           servicebus_receiver.complete_message(message)\n\
    \n   ````\n"
- uid: azure.servicebus.ServiceBusReceiver.renew_message_lock
  name: renew_message_lock
  summary: 'Renew the message lock.


    This will maintain the lock on the message to ensure it is not returned to the
    queue

    to be reprocessed.


    In order to complete (or otherwise settle) the message, the lock must be maintained,

    and cannot already have expired; an expired lock cannot be renewed.


    Messages received via RECEIVE_AND_DELETE mode are not locked, and therefore cannot
    be renewed.

    This operation is only available for non-sessionful messages as well.'
  signature: renew_message_lock(message, **kwargs)
  parameters:
  - name: message
    description: The message to renew the lock for.
    isRequired: true
    types:
    - <xref:azure.servicebus.ServiceBusReceivedMessage>
  return:
    description: The utc datetime the lock is set to expire at.
    types:
    - <xref:datetime.datetime>
  examples:
  - "Renew the lock on a received message.<!--[!code-python[Main](les\\sync_samples\\\
    sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\\
    a\\\\1\\\\s\\\\dist_temp\\\\4\\\\azure-servicebus-7.2.0\\\\samples\\\\sync_samples\\\
    \\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n       messages = servicebus_receiver.receive_messages(max_wait_time=5)\n\
    \       for message in messages:\n           servicebus_receiver.renew_message_lock(message)\n\
    \n   ````\n"
attributes:
- uid: azure.servicebus.ServiceBusReceiver.session
  name: session
  summary: 'Get the ServiceBusSession object linked with the receiver. Session is
    only available to session-enabled

    entities, it would return None if called on a non-sessionful receiver.'
  return:
    types:
    - <xref:azure.servicebus.ServiceBusSession>
  examples:
  - "Get session from a receiver<!--[!code-python[Main](les\\sync_samples\\sample_code_servicebus.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\
    \\4\\\\azure-servicebus-7.2.0\\\\samples\\\\sync_samples\\\\sample_code_servicebus.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n       with servicebus_client.get_queue_receiver(queue_name=queue_name, session_id=session_id)\
    \ as receiver:\n           session = receiver.session\n\n   ````\n"
