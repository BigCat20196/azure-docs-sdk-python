### YamlMime:PythonClass
uid: azure.servicebus.ReceivedMessage
name: ReceivedMessage
fullName: azure.servicebus.ReceivedMessage
module: azure.servicebus
inheritances:
- azure.servicebus._common.message.PeekMessage
summary: A Service Bus Message received from service side.
constructor:
  syntax: 'ReceivedMessage(message, mode=<ReceiveSettleMode.PeekLock: <ReceiverSettleMode.PeekLock:
    1>>, **kwargs)'
variables:
- description: Error when AutoLockRenew is used and it fails to renew the message
    lock.
  name: auto_renew_error
  types:
  - azure.servicebus.AutoLockRenewTimeout
  - azure.servicebus.AutoLockRenewFailed
examples:
- "Checking the properties on a received message.<!--[!code-python[Main](les\\sync_samples\\\
  sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
  : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\a\\\
  \\1\\\\s\\\\dist_temp\\\\8\\\\azure-servicebus-7.0.0b3\\\\samples\\\\sync_samples\\\
  \\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"language\": \"python\"\
  , \"linenos\": false, \"highlight_args\": {\"linenostart\": 1}} -->\n\n````python\n\
  \n       messages = servicebus_receiver.receive(max_wait_time=5)\n       for message\
  \ in messages:\n           print(\"Receiving: {}\".format(message))\n          \
  \ print(\"Time to live: {}\".format(message.time_to_live))\n           print(\"\
  Sequence number: {}\".format(message.sequence_number))\n           print(\"Enqueue\
  \ Sequence numger: {}\".format(message.enqueue_sequence_number))\n           print(\"\
  Partition ID: {}\".format(message.partition_id))\n           print(\"Partition Key:\
  \ {}\".format(message.partition_key))\n           print(\"User Properties: {}\"\
  .format(message.user_properties))\n           print(\"Annotations: {}\".format(message.annotations))\n\
  \           print(\"Delivery count: {}\".format(message.header.delivery_count))\n\
  \           print(\"Message ID: {}\".format(message.properties.message_id))\n  \
  \         print(\"Locked until: {}\".format(message.locked_until_utc))\n       \
  \    print(\"Lock Token: {}\".format(message.lock_token))\n           print(\"Enqueued\
  \ time: {}\".format(message.enqueued_time_utc))\n\n   ````\n"
methods:
- uid: azure.servicebus.ReceivedMessage.abandon
  name: abandon
  summary: 'Abandon the message.


    This message will be returned to the queue and made available to be received again.'
  signature: abandon()
  return:
    types:
    - <xref:None>
- uid: azure.servicebus.ReceivedMessage.complete
  name: complete
  summary: 'Complete the message.


    This removes the message from the queue.'
  signature: complete()
  return:
    types:
    - <xref:None>
- uid: azure.servicebus.ReceivedMessage.dead_letter
  name: dead_letter
  summary: 'Move the message to the Dead Letter queue.


    The Dead Letter queue is a sub-queue that can be

    used to store messages that failed to process correctly, or otherwise require
    further inspection

    or processing. The queue can also be configured to send expired messages to the
    Dead Letter queue.'
  signature: dead_letter(reason=None, description=None)
  parameters:
  - name: reason
    description: The reason for dead-lettering the message.
    defaultValue: None
    types:
    - <xref:str>
  - name: description
    description: The detailed description for dead-lettering the message.
    defaultValue: None
    types:
    - <xref:str>
  return:
    types:
    - <xref:None>
- uid: azure.servicebus.ReceivedMessage.defer
  name: defer
  summary: 'Defer the message.


    This message will remain in the queue but must be requested

    specifically by its sequence number in order to be received.'
  signature: defer()
  return:
    types:
    - <xref:None>
- uid: azure.servicebus.ReceivedMessage.renew_lock
  name: renew_lock
  summary: 'Renew the message lock.


    This will maintain the lock on the message to ensure

    it is not returned to the queue to be reprocessed. In order to complete (or otherwise
    settle)

    the message, the lock must be maintained. Messages received via ReceiveAndDelete
    mode are not

    locked, and therefore cannot be renewed. This operation can also be performed
    as a threaded

    background task by registering the message with an *azure.servicebus.AutoLockRenew*
    instance.

    This operation is only available for non-sessionful messages.'
  signature: renew_lock()
  return:
    types:
    - <xref:None>
attributes:
- uid: azure.servicebus.ReceivedMessage.expired
  name: expired
  summary: '*rtype* -- bool'
- uid: azure.servicebus.ReceivedMessage.lock_token
  name: lock_token
  summary: '*rtype* -- ~uuid.UUID or str'
- uid: azure.servicebus.ReceivedMessage.locked_until_utc
  name: locked_until_utc
  summary: '*rtype* -- datetime.datetime'
- uid: azure.servicebus.ReceivedMessage.settled
  name: settled
  summary: 'Whether the message has been settled.


    This will aways be *True* for a message received using ReceiveAndDelete mode,

    otherwise it will be *False* until the message is completed or otherwise settled.'
  return:
    types:
    - <xref:bool>
