### YamlMime:PythonClass
uid: azure.eventhub.aio.EventHubConsumerClient
name: EventHubConsumerClient
fullName: azure.eventhub.aio.EventHubConsumerClient
module: azure.eventhub.aio
inheritances:
- azure.eventhub.aio._client_base_async.ClientBaseAsync
summary: 'The EventHubConsumerClient class defines a high level interface for

  receiving events from the Azure Event Hubs service.


  The main goal of *EventHubConsumerClient* is to receive events from all partitions
  of an EventHub with

  load-balancing and checkpointing.


  When multiple *EventHubConsumerClient* instances are running against the same event
  hub, consumer group and

  checkpointing location, the partitions will be evenly distributed among them.


  To enable load-balancing and persisted checkpoints, checkpoint_store must be set
  when creating the

  *EventHubConsumerClient*.

  If a checkpoint store is not provided, the checkpoint will be maintained internally
  in memory.


  An *EventHubConsumerClient* can also receive from a specific partition when you
  call its method *receive()* or

  *receive_batch()* and specify the partition_id.

  Load-balancing won''t work in single-partition mode. But users can still save checkpoints
  if the checkpoint_store

  is set.'
constructor:
  syntax: 'EventHubConsumerClient(fully_qualified_namespace: str, eventhub_name: str,
    consumer_group: str, credential: typing.Union[AsyncTokenCredential, azure.core.credentials.AzureSasCredential],
    **kwargs) -> None'
  parameters:
  - name: fully_qualified_namespace
    description: 'The fully qualified host name for the Event Hubs namespace.

      The namespace format is: *<yournamespace>.servicebus.windows.net*.'
    isRequired: true
    types:
    - <xref:str>
  - name: eventhub_name
    description: The path of the specific Event Hub to connect the client to.
    isRequired: true
    types:
    - <xref:str>
  - name: consumer_group
    description: Receive events from the event hub for this consumer group.
    isRequired: true
    types:
    - <xref:str>
  - name: credential
    description: 'The credential object used for authentication which

      implements a particular interface for getting tokens. It accepts

      <xref:azure.eventhub.aio.EventHubSharedKeyCredential>, or credential objects

      generated by the azure-identity library and objects that implement the *get_token(self,
      *scopes)* method.'
    isRequired: true
    types:
    - <xref:azure.core.credentials_async.AsyncTokenCredential> or <xref:azure.core.credentials.AzureSasCredential>
examples:
- "Create a new instance of the EventHubConsumerClient.<!--[!code-python[Main](les\\\
  async_samples\\sample_code_eventhub_async.py )]-->\n\n<!-- literal_block {\"ids\"\
  : [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
  : \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\107\\\\azure-eventhub-5.4.0\\\\samples\\\\\
  async_samples\\\\sample_code_eventhub_async.py\", \"xml:space\": \"preserve\", \"\
  force\": false, \"language\": \"python\", \"highlight_args\": {\"linenostart\":\
  \ 1}, \"linenos\": false} -->\n\n````python\n\n   import os\n   from azure.eventhub.aio\
  \ import EventHubConsumerClient, EventHubSharedKeyCredential\n\n   fully_qualified_namespace\
  \ = os.environ['EVENT_HUB_HOSTNAME']\n   eventhub_name = os.environ['EVENT_HUB_NAME']\n\
  \   shared_access_policy = os.environ['EVENT_HUB_SAS_POLICY']\n   shared_access_key\
  \ = os.environ['EVENT_HUB_SAS_KEY']\n\n   consumer = EventHubConsumerClient(fully_qualified_namespace=fully_qualified_namespace,\n\
  \                                     consumer_group='$Default',\n             \
  \                        eventhub_name=eventhub_name,\n                        \
  \             credential=EventHubSharedKeyCredential(shared_access_policy, shared_access_key))\n\
  \n   ````\n"
methods:
- uid: azure.eventhub.aio.EventHubConsumerClient.close
  name: close
  summary: Stop retrieving events from the Event Hub and close the underlying AMQP
    connection and links.
  signature: close() -> None
  return:
    types:
    - <xref:None>
  examples:
  - "Close down the client.<!--[!code-python[Main](les\\async_samples\\sample_code_eventhub_async.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\
    \\107\\\\azure-eventhub-5.4.0\\\\samples\\\\async_samples\\\\sample_code_eventhub_async.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n   import os\n\n   event_hub_connection_str = os.environ['EVENT_HUB_CONN_STR']\n\
    \   eventhub_name = os.environ['EVENT_HUB_NAME']\n\n   from azure.eventhub.aio\
    \ import EventHubConsumerClient\n   consumer = EventHubConsumerClient.from_connection_string(\n\
    \       conn_str=event_hub_connection_str,\n       consumer_group='$Default',\n\
    \       eventhub_name=eventhub_name  # EventHub name should be specified if it\
    \ doesn't show up in connection string.\n   )\n\n   logger = logging.getLogger(\"\
    azure.eventhub\")\n\n   async def on_event(partition_context, event):\n      \
    \ # Put your code here.\n       # If the operation is i/o intensive, async will\
    \ have better performance.\n       logger.info(\"Received event from partition:\
    \ {}\".format(partition_context.partition_id))\n\n   # The receive method is a\
    \ coroutine which will be blocking when awaited.\n   # It can be executed in an\
    \ async task for non-blocking behavior, and combined with the 'close' method.\n\
    \n   recv_task = asyncio.ensure_future(consumer.receive(on_event=on_event))\n\
    \   await asyncio.sleep(3)  # keep receiving for 3 seconds\n   recv_task.cancel()\
    \  # stop receiving\n\n   # Close down the consumer handler explicitly.\n   await\
    \ consumer.close()\n\n   ````\n"
- uid: azure.eventhub.aio.EventHubConsumerClient.from_connection_string
  name: from_connection_string
  summary: Create an EventHubConsumerClient from a connection string.
  signature: 'from_connection_string(conn_str: str, consumer_group: str, *, eventhub_name:
    str = None, logging_enable: bool = False, http_proxy: typing.Dict[str, typing.Union[str,
    int]] = None, auth_timeout: float = 60, user_agent: str = None, retry_total: int
    = 3, transport_type: Transporttyping.Type = None, checkpoint_store: CheckpointStore
    = None, load_balancing_interval: float = 10, **kwargs: typing.Any) -> ''EventHubConsumerClient'''
  parameters:
  - name: conn_str
    description: The connection string of an Event Hub.
    isRequired: true
    types:
    - <xref:str>
  - name: consumer_group
    description: Receive events from the Event Hub for this consumer group.
    isRequired: true
    types:
    - <xref:str>
  - name: consumer_group
    isRequired: true
  return:
    types:
    - <xref:azure.eventhub.aio.EventHubConsumerClient>
  examples:
  - "Create a new instance of the EventHubConsumerClient from connection string.<!--[!code-python[Main](les\\\
    async_samples\\sample_code_eventhub_async.py )]-->\n\n<!-- literal_block {\"ids\"\
    : [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\107\\\\azure-eventhub-5.4.0\\\\samples\\\
    \\async_samples\\\\sample_code_eventhub_async.py\", \"xml:space\": \"preserve\"\
    , \"force\": false, \"language\": \"python\", \"highlight_args\": {\"linenostart\"\
    : 1}, \"linenos\": false} -->\n\n````python\n\n   import os\n   from azure.eventhub.aio\
    \ import EventHubConsumerClient\n   event_hub_connection_str = os.environ['EVENT_HUB_CONN_STR']\n\
    \   eventhub_name = os.environ['EVENT_HUB_NAME']\n   consumer = EventHubConsumerClient.from_connection_string(\n\
    \       conn_str=event_hub_connection_str,\n       consumer_group='$Default',\n\
    \       eventhub_name=eventhub_name  # EventHub name should be specified if it\
    \ doesn't show up in connection string.\n   )\n\n   ````\n"
- uid: azure.eventhub.aio.EventHubConsumerClient.get_eventhub_properties
  name: get_eventhub_properties
  summary: "Get properties of the Event Hub.\n\nKeys in the returned dictionary include:\n\
    \n   * *eventhub_name* (str) \n\n   * *created_at* (UTC datetime.datetime) \n\n\
    \   * *partition_ids* (list[str])"
  signature: get_eventhub_properties() -> typing.Dict[str, typing.Any]
  return:
    types:
    - <xref:dict>
- uid: azure.eventhub.aio.EventHubConsumerClient.get_partition_ids
  name: get_partition_ids
  summary: Get partition IDs of the Event Hub.
  signature: get_partition_ids() -> typing.List[str]
  return:
    types:
    - <xref:list>[<xref:str>]
- uid: azure.eventhub.aio.EventHubConsumerClient.get_partition_properties
  name: get_partition_properties
  summary: "Get properties of the specified partition.\n\nKeys in the properties dictionary\
    \ include:\n\n   * *eventhub_name* (str) \n\n   * *id* (str) \n\n   * *beginning_sequence_number*\
    \ (int) \n\n   * *last_enqueued_sequence_number* (int) \n\n   * *last_enqueued_offset*\
    \ (str) \n\n   * *last_enqueued_time_utc* (UTC datetime.datetime) \n\n   * *is_empty*\
    \ (bool)"
  signature: 'get_partition_properties(partition_id: str) -> typing.Dict[str, typing.Any]'
  parameters:
  - name: partition_id
    description: The target partition ID.
    isRequired: true
    types:
    - <xref:str>
  return:
    types:
    - <xref:dict>
- uid: azure.eventhub.aio.EventHubConsumerClient.receive
  name: receive
  summary: Receive events from partition(s), with optional load-balancing and checkpointing.
  signature: 'receive(on_event: typing.Callable[[PartitionContext, EventData]], typing.Awaitable[None],
    *, max_wait_time: float = None, partition_id: str = None, owner_level: int = None,
    prefetch: int = 300, track_last_enqueued_event_properties: bool = False, starting_position:
    typing.Union[str, int, datetime.datetime, typing.Dict[str, typing.Any]] = None,
    starting_position_inclusive: typing.Union[bool, typing.Dict[str, bool]] = False,
    on_error: typing.Callable[[PartitionContext, Exception], typing.Awaitable[None]]
    = None, on_partition_initialize: typing.Callable[PartitionContext, typing.Awaitable[None]]
    = None, on_partition_close: typing.Callable[[PartitionContext, CloseReason], typing.Awaitable[None]]
    = None) -> None'
  parameters:
  - name: on_event
    description: 'The callback function for handling a received event. The callback
      takes two

      parameters: *partition_context* which contains partition context and *event*
      which is the received event.

      The callback function should be defined like: *on_event(partition_context, event)*.

      For detailed partition context information, please refer to

      <xref:azure.eventhub.aio.PartitionContext>.'
    isRequired: true
    types:
    - <xref:azure.eventhub.aio.Callable>[<xref:azure.eventhub.aio.PartitionContext>,
      <xref:azure.eventhub.aio.Optional>[<xref:azure.eventhub.EventData>]]
  return:
    types:
    - <xref:None>
  examples:
  - "Receive events from the EventHub.<!--[!code-python[Main](les\\async_samples\\\
    sample_code_eventhub_async.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\\
    a\\\\1\\\\s\\\\dist_temp\\\\107\\\\azure-eventhub-5.4.0\\\\samples\\\\async_samples\\\
    \\sample_code_eventhub_async.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n       logger = logging.getLogger(\"azure.eventhub\"\
    )\n\n       async def on_event(partition_context, event):\n           # Put your\
    \ code here.\n           # If the operation is i/o intensive, async will have\
    \ better performance.\n           logger.info(\"Received event from partition:\
    \ {}\".format(partition_context.partition_id))\n\n       async with consumer:\n\
    \           await consumer.receive(\n               on_event=on_event,\n     \
    \          starting_position=\"-1\",  # \"-1\" is from the beginning of the partition.\n\
    \           )\n\n   ````\n"
- uid: azure.eventhub.aio.EventHubConsumerClient.receive_batch
  name: receive_batch
  summary: Receive events from partition(s) in batches, with optional load-balancing
    and checkpointing.
  signature: 'receive_batch(on_event_batch: typing.Callable[[PartitionContext, typing.List[EventData]],
    typing.Awaitable[None]], *, max_batch_size: int = 300, max_wait_time: float =
    None, partition_id: str = None, owner_level: int = None, prefetch: int = 300,
    track_last_enqueued_event_properties: bool = False, starting_position: typing.Union[str,
    int, datetime.datetime, typing.Dict[str, typing.Any]] = None, starting_position_inclusive:
    typing.Union[bool, typing.Dict[str, bool]] = False, on_error: typing.Callable[[PartitionContext,
    Exception], typing.Awaitable[None]] = None, on_partition_initialize: typing.Callable[PartitionContext,
    typing.Awaitable[None]] = None, on_partition_close: typing.Callable[[PartitionContext,
    CloseReason], typing.Awaitable[None]] = None) -> None'
  parameters:
  - name: on_event_batch
    description: 'The callback function for handling a batch of received events. The
      callback takes two

      parameters: *partition_context* which contains partition context and *event_batch*,
      which is the received

      events. The callback function should be defined like: *on_event_batch(partition_context,
      event_batch)*.

      *event_batch* could be an empty list if *max_wait_time* is not None nor 0 and
      no event is received

      after *max_wait_time*.

      For detailed partition context information, please refer to

      <xref:azure.eventhub.aio.PartitionContext>.'
    isRequired: true
    types:
    - <xref:azure.eventhub.aio.Callable>[<xref:azure.eventhub.aio.PartitionContext>,
      <xref:azure.eventhub.aio.List>[<xref:azure.eventhub.EventData>]]
  return:
    types:
    - <xref:None>
  examples:
  - "Receive events in batches from the EventHub.<!--[!code-python[Main](les\\async_samples\\\
    sample_code_eventhub_async.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\\
    a\\\\1\\\\s\\\\dist_temp\\\\107\\\\azure-eventhub-5.4.0\\\\samples\\\\async_samples\\\
    \\sample_code_eventhub_async.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n       logger = logging.getLogger(\"azure.eventhub\"\
    )\n\n       async def on_event_batch(partition_context, event_batch):\n      \
    \     # Put your code here.\n           # If the operation is i/o intensive, async\
    \ will have better performance.\n           logger.info(\n               \"{}\
    \ events received from partition: {}\".format(len(event_batch), partition_context.partition_id)\n\
    \           )\n\n       async with consumer:\n           await consumer.receive_batch(\n\
    \               on_event_batch=on_event_batch,\n               starting_position=\"\
    -1\",  # \"-1\" is from the beginning of the partition.\n           )\n\n   ````\n"
