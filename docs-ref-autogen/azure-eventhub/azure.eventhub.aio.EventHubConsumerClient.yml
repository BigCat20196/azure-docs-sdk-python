### YamlMime:PythonClass
uid: azure.eventhub.aio.EventHubConsumerClient
name: EventHubConsumerClient
fullName: azure.eventhub.aio.EventHubConsumerClient
module: azure.eventhub.aio
inheritances:
- azure.eventhub.aio._client_base_async.ClientBaseAsync
summary: 'The EventHubConsumerClient class defines a high level interface for

  receiving events from the Azure Event Hubs service.


  The main goal of *EventHubConsumerClient* is to receive events from all partitions
  of an EventHub with

  load-balancing and checkpointing.


  When multiple *EventHubConsumerClient* instances are running against the same event
  hub, consumer group and

  checkpointing location, the partitions will be evenly distributed among them.


  To enable load-balancing and persisted checkpoints, checkpoint_store must be set
  when creating the

  *EventHubConsumerClient*.

  If a checkpoint store is not provided, the checkpoint will be maintained internally
  in memory.


  An *EventHubConsumerClient* can also receive from a specific partition when you
  call its method *receive()* or

  *receive_batch()* and specify the partition_id.

  Load-balancing won''t work in single-partition mode. But users can still save checkpoints
  if the checkpoint_store

  is set.'
constructor:
  syntax: 'EventHubConsumerClient(fully_qualified_namespace: str, eventhub_name: str,
    consumer_group: str, credential: typing.Union[AsyncTokenCredential, azure.core.credentials.AzureSasCredential,
    azure.core.credentials.AzureNamedKeyCredential], **kwargs) -> None'
  parameters:
  - name: fully_qualified_namespace
    description: 'The fully qualified host name for the Event Hubs namespace.

      The namespace format is: *<yournamespace>.servicebus.windows.net*.'
    isRequired: true
    types:
    - <xref:str>
  - name: eventhub_name
    description: The path of the specific Event Hub to connect the client to.
    isRequired: true
    types:
    - <xref:str>
  - name: consumer_group
    description: Receive events from the event hub for this consumer group.
    isRequired: true
    types:
    - <xref:str>
  - name: credential
    description: 'The credential object used for authentication which

      implements a particular interface for getting tokens. It accepts

      <xref:azure.eventhub.aio.EventHubSharedKeyCredential>, or credential objects

      generated by the azure-identity library and objects that implement the *get_token(self,
      *scopes)* method.'
    isRequired: true
    types:
    - <xref:azure.core.credentials_async.AsyncTokenCredential>
    - '<xref:azure.core.credentials.AzureSasCredential>

      or <xref:azure.core.credentials.AzureNamedKeyCredential>'
variables:
- description: Whether to output network trace logs to the logger. Default is *False*.
  name: logging_enable
  types:
  - <xref:bool>
- description: 'The time in seconds to wait for a token to be authorized by the service.

    The default value is 60 seconds. If set to 0, no timeout will be enforced from
    the client.'
  name: auth_timeout
  types:
  - <xref:float>
- description: If specified, this will be added in front of the user agent string.
  name: user_agent
  types:
  - <xref:str>
- description: 'The total number of attempts to redo a failed operation when an error
    occurs.

    Default value is 3. The context of *retry_total* in receiving is special: The
    *receive* method is implemented

    by a while-loop calling internal receive method in each iteration. In the *receive*
    case,

    *retry_total* specifies the numbers of retry after error raised by internal receive
    method in the while-loop.

    If retry attempts are exhausted, the *on_error* callback will be called (if provided)
    with the error information.

    The failed internal partition consumer will be closed (*on_partition_close* will
    be called if provided) and

    new internal partition consumer will be created (*on_partition_initialize* will
    be called if provided) to resume

    receiving.'
  name: retry_total
  types:
  - <xref:int>
- description: 'Timeout, in seconds, after which this client will close the underlying
    connection

    if there is no further activity. By default the value is None, meaning that the
    client will not shutdown due to

    inactivity unless initiated by the service.'
  name: idle_timeout
  types:
  - <xref:float>
- description: 'The type of transport protocol that will be used for communicating
    with

    the Event Hubs service. Default is *TransportType.Amqp* in which case port 5671
    is used.

    If the port 5671 is unavailable/blocked in the network environment, *TransportType.AmqpOverWebsocket*
    could

    be used instead which uses port 443 for communication.'
  name: transport_type
  types:
  - <xref:azure.eventhub.TransportType>
- description: 'HTTP proxy settings. This must be a dictionary with the following

    keys: *''proxy_hostname''* (str value) and *''proxy_port''* (int value).

    Additionally the following keys may also be present: *''username'', ''password''*.'
  name: http_proxy
  types:
  - <xref:dict>
- description: 'A manager that stores the partition load-balancing and checkpoint
    data

    when receiving events. The checkpoint store will be used in both cases of receiving
    from all partitions

    or a single partition. In the latter case load-balancing does not apply.

    If a checkpoint store is not provided, the checkpoint will be maintained internally

    in memory, and the *EventHubConsumerClient* instance will receive events without
    load-balancing.'
  name: checkpoint_store
  types:
  - <xref:azure.eventhub.aio.CheckpointStore>
- description: 'When load-balancing kicks in. This is the interval, in seconds,

    between two load-balancing evaluations. Default is 10 seconds.'
  name: load_balancing_interval
  types:
  - <xref:float>
- description: 'A partition ownership will expire after this number

    of seconds. Every load-balancing evaluation will automatically extend the ownership
    expiration time.

    Default is 6 * load_balancing_interval, i.e. 60 seconds when using the default
    load_balancing_interval

    of 10 seconds.'
  name: partition_ownership_expiration_interval
  types:
  - <xref:float>
- description: 'When load-balancing kicks in,

    it will use this strategy to claim and balance the partition ownership.

    Use "greedy" or *LoadBalancingStrategy.GREEDY* for the greedy strategy, which,
    for every

    load-balancing evaluation, will grab as many unclaimed partitions required to
    balance the load.

    Use "balanced" or *LoadBalancingStrategy.BALANCED* for the balanced strategy,
    which, for every load-balancing

    evaluation, claims only one partition that is not claimed by other *EventHubConsumerClient*.

    If all partitions of an EventHub are claimed by other *EventHubConsumerClient*
    and this client has claimed

    too few partitions, this client will steal one partition from other clients for
    every load-balancing

    evaluation regardless of the load balancing strategy.

    Greedy strategy is used by default.'
  name: load_balancing_strategy
  types:
  - <xref:str>
  - <xref:azure.eventhub.LoadBalancingStrategy>
- description: 'The custom endpoint address to use for establishing a connection to

    the Event Hubs service, allowing network requests to be routed through any application
    gateways or

    other paths needed for the host environment. Default is None.

    The format would be like "sb://<custom_endpoint_hostname>:<custom_endpoint_port>".

    If port is not specified in the *custom_endpoint_address*, by default port 443
    will be used.'
  name: custom_endpoint_address
  types:
  - <xref:str>
- description: 'Path to the custom CA_BUNDLE file of the SSL certificate which is
    used to

    authenticate the identity of the connection endpoint.

    Default is None in which case *certifi.where()* will be used.'
  name: connection_verify
  types:
  - <xref:str>
examples:
- "Create a new instance of the EventHubConsumerClient.<!--[!code-python[Main](les\\\
  async_samples\\sample_code_eventhub_async.py )]-->\n\n<!-- literal_block {\"ids\"\
  : [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
  : \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\107\\\\azure-eventhub-5.5.0\\\\samples\\\\\
  async_samples\\\\sample_code_eventhub_async.py\", \"xml:space\": \"preserve\", \"\
  force\": false, \"language\": \"python\", \"highlight_args\": {\"linenostart\":\
  \ 1}, \"linenos\": false} -->\n\n````python\n\n   import os\n   from azure.eventhub.aio\
  \ import EventHubConsumerClient, EventHubSharedKeyCredential\n\n   fully_qualified_namespace\
  \ = os.environ['EVENT_HUB_HOSTNAME']\n   eventhub_name = os.environ['EVENT_HUB_NAME']\n\
  \   shared_access_policy = os.environ['EVENT_HUB_SAS_POLICY']\n   shared_access_key\
  \ = os.environ['EVENT_HUB_SAS_KEY']\n\n   consumer = EventHubConsumerClient(fully_qualified_namespace=fully_qualified_namespace,\n\
  \                                     consumer_group='$Default',\n             \
  \                        eventhub_name=eventhub_name,\n                        \
  \             credential=EventHubSharedKeyCredential(shared_access_policy, shared_access_key))\n\
  \n   ````\n"
methods:
- uid: azure.eventhub.aio.EventHubConsumerClient.close
  name: close
  summary: Stop retrieving events from the Event Hub and close the underlying AMQP
    connection and links.
  signature: close() -> None
  return:
    types:
    - <xref:None>
  examples:
  - "Close down the client.<!--[!code-python[Main](les\\async_samples\\sample_code_eventhub_async.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\
    \\107\\\\azure-eventhub-5.5.0\\\\samples\\\\async_samples\\\\sample_code_eventhub_async.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n   import os\n\n   event_hub_connection_str = os.environ['EVENT_HUB_CONN_STR']\n\
    \   eventhub_name = os.environ['EVENT_HUB_NAME']\n\n   from azure.eventhub.aio\
    \ import EventHubConsumerClient\n   consumer = EventHubConsumerClient.from_connection_string(\n\
    \       conn_str=event_hub_connection_str,\n       consumer_group='$Default',\n\
    \       eventhub_name=eventhub_name  # EventHub name should be specified if it\
    \ doesn't show up in connection string.\n   )\n\n   logger = logging.getLogger(\"\
    azure.eventhub\")\n\n   async def on_event(partition_context, event):\n      \
    \ # Put your code here.\n       # If the operation is i/o intensive, async will\
    \ have better performance.\n       logger.info(\"Received event from partition:\
    \ {}\".format(partition_context.partition_id))\n\n   # The receive method is a\
    \ coroutine which will be blocking when awaited.\n   # It can be executed in an\
    \ async task for non-blocking behavior, and combined with the 'close' method.\n\
    \n   recv_task = asyncio.ensure_future(consumer.receive(on_event=on_event))\n\
    \   await asyncio.sleep(3)  # keep receiving for 3 seconds\n   recv_task.cancel()\
    \  # stop receiving\n\n   # Close down the consumer handler explicitly.\n   await\
    \ consumer.close()\n\n   ````\n"
- uid: azure.eventhub.aio.EventHubConsumerClient.from_connection_string
  name: from_connection_string
  summary: Create an EventHubConsumerClient from a connection string.
  signature: 'from_connection_string(conn_str: str, consumer_group: str, *, eventhub_name:
    str = None, logging_enable: bool = False, http_proxy: typing.Dict[str, typing.Union[str,
    int]] = None, auth_timeout: float = 60, user_agent: str = None, retry_total: int
    = 3, transport_type: Transporttyping.Type = None, checkpoint_store: CheckpointStore
    = None, load_balancing_interval: float = 10, **kwargs: typing.Any) -> EventHubConsumerClient'
  parameters:
  - name: conn_str
    description: The connection string of an Event Hub.
    isRequired: true
    types:
    - <xref:str>
  - name: consumer_group
    description: Receive events from the Event Hub for this consumer group.
    isRequired: true
    types:
    - <xref:str>
  - name: consumer_group
    isRequired: true
  return:
    types:
    - <xref:azure.eventhub.aio.EventHubConsumerClient>
  examples:
  - "Create a new instance of the EventHubConsumerClient from connection string.<!--[!code-python[Main](les\\\
    async_samples\\sample_code_eventhub_async.py )]-->\n\n<!-- literal_block {\"ids\"\
    : [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\107\\\\azure-eventhub-5.5.0\\\\samples\\\
    \\async_samples\\\\sample_code_eventhub_async.py\", \"xml:space\": \"preserve\"\
    , \"force\": false, \"language\": \"python\", \"highlight_args\": {\"linenostart\"\
    : 1}, \"linenos\": false} -->\n\n````python\n\n   import os\n   from azure.eventhub.aio\
    \ import EventHubConsumerClient\n   event_hub_connection_str = os.environ['EVENT_HUB_CONN_STR']\n\
    \   eventhub_name = os.environ['EVENT_HUB_NAME']\n   consumer = EventHubConsumerClient.from_connection_string(\n\
    \       conn_str=event_hub_connection_str,\n       consumer_group='$Default',\n\
    \       eventhub_name=eventhub_name  # EventHub name should be specified if it\
    \ doesn't show up in connection string.\n   )\n\n   ````\n"
- uid: azure.eventhub.aio.EventHubConsumerClient.get_eventhub_properties
  name: get_eventhub_properties
  summary: "Get properties of the Event Hub.\n\nKeys in the returned dictionary include:\n\
    \n   * *eventhub_name* (str) \n\n   * *created_at* (UTC datetime.datetime) \n\n\
    \   * *partition_ids* (list[str])"
  signature: get_eventhub_properties() -> typing.Dict[str, typing.Any]
  return:
    types:
    - <xref:dict>
  exceptions:
  - type: azure.eventhub.exceptions.EventHubError
- uid: azure.eventhub.aio.EventHubConsumerClient.get_partition_ids
  name: get_partition_ids
  summary: Get partition IDs of the Event Hub.
  signature: get_partition_ids() -> typing.List[str]
  return:
    types:
    - <xref:list>[<xref:str>]
  exceptions:
  - type: azure.eventhub.exceptions.EventHubError
- uid: azure.eventhub.aio.EventHubConsumerClient.get_partition_properties
  name: get_partition_properties
  summary: "Get properties of the specified partition.\n\nKeys in the properties dictionary\
    \ include:\n\n   * *eventhub_name* (str) \n\n   * *id* (str) \n\n   * *beginning_sequence_number*\
    \ (int) \n\n   * *last_enqueued_sequence_number* (int) \n\n   * *last_enqueued_offset*\
    \ (str) \n\n   * *last_enqueued_time_utc* (UTC datetime.datetime) \n\n   * *is_empty*\
    \ (bool)"
  signature: 'get_partition_properties(partition_id: str) -> typing.Dict[str, typing.Any]'
  parameters:
  - name: partition_id
    description: The target partition ID.
    isRequired: true
    types:
    - <xref:str>
  return:
    types:
    - <xref:dict>
  exceptions:
  - type: azure.eventhub.exceptions.EventHubError
- uid: azure.eventhub.aio.EventHubConsumerClient.receive
  name: receive
  summary: Receive events from partition(s), with optional load-balancing and checkpointing.
  signature: 'receive(on_event: typing.Callable[[PartitionContext, EventData]], typing.Awaitable[None],
    *, max_wait_time: float = None, partition_id: str = None, owner_level: int = None,
    prefetch: int = 300, track_last_enqueued_event_properties: bool = False, starting_position:
    typing.Union[str, int, datetime.datetime, typing.Dict[str, typing.Any]] = None,
    starting_position_inclusive: typing.Union[bool, typing.Dict[str, bool]] = False,
    on_error: typing.Callable[[PartitionContext, Exception], typing.Awaitable[None]]
    = None, on_partition_initialize: typing.Callable[PartitionContext, typing.Awaitable[None]]
    = None, on_partition_close: typing.Callable[[PartitionContext, CloseReason], typing.Awaitable[None]]
    = None) -> None'
  parameters:
  - name: on_event
    description: 'The callback function for handling a received event. The callback
      takes two

      parameters: *partition_context* which contains partition context and *event*
      which is the received event.

      The callback function should be defined like: *on_event(partition_context, event)*.

      For detailed partition context information, please refer to

      <xref:azure.eventhub.aio.PartitionContext>.'
    isRequired: true
    types:
    - <xref:azure.eventhub.aio.Callable>[<xref:azure.eventhub.aio.PartitionContext>,
      <xref:azure.eventhub.aio.Optional>[<xref:azure.eventhub.EventData>]]
  return:
    types:
    - <xref:None>
  examples:
  - "Receive events from the EventHub.<!--[!code-python[Main](les\\async_samples\\\
    sample_code_eventhub_async.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\\
    a\\\\1\\\\s\\\\dist_temp\\\\107\\\\azure-eventhub-5.5.0\\\\samples\\\\async_samples\\\
    \\sample_code_eventhub_async.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n       logger = logging.getLogger(\"azure.eventhub\"\
    )\n\n       async def on_event(partition_context, event):\n           # Put your\
    \ code here.\n           # If the operation is i/o intensive, async will have\
    \ better performance.\n           logger.info(\"Received event from partition:\
    \ {}\".format(partition_context.partition_id))\n\n       async with consumer:\n\
    \           await consumer.receive(\n               on_event=on_event,\n     \
    \          starting_position=\"-1\",  # \"-1\" is from the beginning of the partition.\n\
    \           )\n\n   ````\n"
- uid: azure.eventhub.aio.EventHubConsumerClient.receive_batch
  name: receive_batch
  summary: Receive events from partition(s) in batches, with optional load-balancing
    and checkpointing.
  signature: 'receive_batch(on_event_batch: typing.Callable[[PartitionContext, typing.List[EventData]],
    typing.Awaitable[None]], *, max_batch_size: int = 300, max_wait_time: float =
    None, partition_id: str = None, owner_level: int = None, prefetch: int = 300,
    track_last_enqueued_event_properties: bool = False, starting_position: typing.Union[str,
    int, datetime.datetime, typing.Dict[str, typing.Any]] = None, starting_position_inclusive:
    typing.Union[bool, typing.Dict[str, bool]] = False, on_error: typing.Callable[[PartitionContext,
    Exception], typing.Awaitable[None]] = None, on_partition_initialize: typing.Callable[PartitionContext,
    typing.Awaitable[None]] = None, on_partition_close: typing.Callable[[PartitionContext,
    CloseReason], typing.Awaitable[None]] = None) -> None'
  parameters:
  - name: on_event_batch
    description: 'The callback function for handling a batch of received events. The
      callback takes two

      parameters: *partition_context* which contains partition context and *event_batch*,
      which is the received

      events. The callback function should be defined like: *on_event_batch(partition_context,
      event_batch)*.

      *event_batch* could be an empty list if *max_wait_time* is not None nor 0 and
      no event is received

      after *max_wait_time*.

      For detailed partition context information, please refer to

      <xref:azure.eventhub.aio.PartitionContext>.'
    isRequired: true
    types:
    - <xref:azure.eventhub.aio.Callable>[<xref:azure.eventhub.aio.PartitionContext>,
      <xref:azure.eventhub.aio.List>[<xref:azure.eventhub.EventData>]]
  return:
    types:
    - <xref:None>
  examples:
  - "Receive events in batches from the EventHub.<!--[!code-python[Main](les\\async_samples\\\
    sample_code_eventhub_async.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\\
    a\\\\1\\\\s\\\\dist_temp\\\\107\\\\azure-eventhub-5.5.0\\\\samples\\\\async_samples\\\
    \\sample_code_eventhub_async.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n       logger = logging.getLogger(\"azure.eventhub\"\
    )\n\n       async def on_event_batch(partition_context, event_batch):\n      \
    \     # Put your code here.\n           # If the operation is i/o intensive, async\
    \ will have better performance.\n           logger.info(\n               \"{}\
    \ events received from partition: {}\".format(len(event_batch), partition_context.partition_id)\n\
    \           )\n\n       async with consumer:\n           await consumer.receive_batch(\n\
    \               on_event_batch=on_event_batch,\n               starting_position=\"\
    -1\",  # \"-1\" is from the beginning of the partition.\n           )\n\n   ````\n"
